# Example Code: Routing Service Processor

Below there are the instructions to build and run this example. All the commands
and syntax used assume a Unix-based system. If you run this example in a
different architecture, please adapt the commands accordingly.

## Building the Example :wrench:

To build the example you will need first to run CMake to generate the build
files. From the directory containing the example sources:

```sh
mkdir build
cd build
cmake .. -DCONNEXTDDS_DIR=$NDDSHOME \
         -DCONNEXTDDS_ARCH=<ARCH> \
         -DBUILD_SHARED_LIBS=ON \
         -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
```

where:

-   the environment variable `$NDDSHOME` shall point to the installation
    directory of RTI Connext.

-   `<ARCH>` shall be replaced with the target architecture where you are
    running the example (e.g., x64Darwin15clang7.0).

On successful execution of CMake, you will find different new files in your
build directory, including a file with name `Makefile`. This file represents a
Unix makefile that contains the rules to build a shared library containing the
|PROCESSOR| plug-in implementation.

Now run:

```sh
make
```

which upon success it will create a shared library file in the build directory.

## Running the Example

To run this example you will need two instances of *RTI Shapes Demo* and a
single instance of *RoutingService*.

To run *RoutingService*, you will need first to set up your environment as
follows:

```sh
export RTI_LD_LIBRARY_PATH=$NDDSHOME/lib/<ARCH>
```

where `<ARCH>` shall be replaced with the target architecture you used to build
the example in the previous step.

### Aggregation

1.  Run one instance of *ShapesDemo* on domain 0. This will be the publisher
    application. Publish a blue squares and blue circles.

2.  Run the other instance of *ShapesDemo* on domain 1. This will be the
    subscriber application. Subscribe to squares, circles and triangles and
    observe how no data is received.

3.  Now run *RoutingService* to cause the aggregation data from the publisher
    application to the subscriber application.

    Run the following command from the example build directory:

    ```sh
    $NDDSHOME/bin/rtiroutingservice \
        -cfgFile ../RsShapesProcessor.xml \
        -cfgName RsShapesAggregator
    ```

    You should see how the subscriber application receives samples from squares,
    circles and triangles. The squares and circles samples are exactly the same
    generated by the publisher application. The triangles are samples are the
    result of the route that contains the *ShapesAggegator*.

4.  Repeat the first step but publish other colors. You should observe the same
    behavior in the subscriber application for the new colors.

5.  In the publisher application, delete all the *DataWriters*. You should see
    the instances being disposed. Now delete all *DataReaders* from the
    subscriber application.

### Splitter

1.  Run one instance of *ShapesDemo* on domain 0. This will be the publisher
    application. Publish a blue squares.

2.  Run the other instance of *ShapesDemo* on domain 1. This will be the
    subscriber application.

    Subscribe to squares, circles and triangles and observe how no data is
    received.

3.  Now run *RoutingService* to cause the aggregation data from the publisher
    application to the subscriber application.

    Run the following command from the example build directory:

    ```sh
    $NDDSHOME/bin/rtiroutingservice \
        -cfgFile ../RsShapesProcessor.xml \
        -cfgName RsShapesSplitter
    ```

    You should see how the subscriber application receives samples from squares,
    circles and triangles. The squares samples are exactly the same generated by
    the publisher application. The circles and triangles are samples are the
    result of the route that contains the *ShapesSplitter*.

4.  Repeat the first step but publish other colors. You should observe the same
    behavior in the subscriber application for the new colors.

5.  In the publisher application, delete all the *DataWriters*. You should see
    the instances being disposed. Now delete all *DataReaders* from the
    subscriber application.
